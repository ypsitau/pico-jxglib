#include <stdio.h>
#include <memory.h>
#include "pico/stdlib.h"
#include "jxglib/FAT.h"

using namespace jxglib;


class DummyDrive : public FAT::PhysicalDriveT<> {
public:
	DummyDrive(BYTE pdrv = 0) : FAT::PhysicalDriveT<>{pdrv} {}
public:
	virtual DSTATUS status() override;
	virtual DSTATUS initialize() override;
	virtual DRESULT read(BYTE* buff, LBA_t sector, UINT count) override;
	virtual DRESULT write(const BYTE* buff, LBA_t sector, UINT count) override;
	virtual DRESULT ioctl_CTRL_SYNC() override;
	virtual DRESULT ioctl_GET_SECTOR_COUNT(LBA_t* pSectorCount) override;
	virtual DRESULT ioctl_GET_SECTOR_SIZE(WORD* pSectorSize) override;
	virtual DRESULT ioctl_GET_BLOCK_SIZE(DWORD* pBlockSize) override;
	virtual DRESULT ioctl_CTRL_TRIM(LBA_t startLBA, LBA_t endLBA) override;
};

DSTATUS DummyDrive::status()
{
	//::printf("status\n");
	return 0x00;	// STA_NOINIT, STA_NODISK, STA_PROTECT
}

DSTATUS DummyDrive::initialize()
{
	::printf("initialize\n");
	return 0x00;	// STA_NOINIT, STA_NODISK, STA_PROTECT
}

DRESULT DummyDrive::read(BYTE* buff, LBA_t sector, UINT count)
{
	::printf("read(sector=%d, count=%d)\n", sector, count);
	const char sector0[] =
		"\xeb\x3c\x90\x6d\x6b\x66\x73\x2e\x66\x61\x74\x00\x02\x04\x01\x00"
		"\x02\x00\x02\x80\x00\xf8\x01\x00\x10\x00\x02\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x80\x00\x29\x49\x67\xbe\x00\x4e\x4f\x20\x4e\x41"
		"\x4d\x45\x20\x20\x20\x20\x46\x41\x54\x31\x32\x20\x20\x20\x0e\x1f"
		"\xbe\x5b\x7c\xac\x22\xc0\x74\x0b\x56\xb4\x0e\xbb\x07\x00\xcd\x10"
		"\x5e\xeb\xf0\x32\xe4\xcd\x16\xcd\x19\xeb\xfe\x54\x68\x69\x73\x20"
		"\x69\x73\x20\x6e\x6f\x74\x20\x61\x20\x62\x6f\x6f\x74\x61\x62\x6c"
		"\x65\x20\x64\x69\x73\x6b\x2e\x20\x20\x50\x6c\x65\x61\x73\x65\x20"
		"\x69\x6e\x73\x65\x72\x74\x20\x61\x20\x62\x6f\x6f\x74\x61\x62\x6c"
		"\x65\x20\x66\x6c\x6f\x70\x70\x79\x20\x61\x6e\x64\x0d\x0a\x70\x72"
		"\x65\x73\x73\x20\x61\x6e\x79\x20\x6b\x65\x79\x20\x74\x6f\x20\x74"
		"\x72\x79\x20\x61\x67\x61\x69\x6e\x20\x2e\x2e\x2e\x20\x0d\x0a\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x55\xaa";
	const char sector1[] =
		"\xf8\xff\xff\x00\xf0\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
	const char sector2[] =
		"\xf8\xff\xff\x00\xf0\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
	const char sector3[] =
		"\x53\x41\x4d\x50\x4c\x45\x20\x20\x54\x58\x54\x20\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\xb7\x3e\x3e\x5a\x03\x00\x93\x01\x00\x00";
	const char sector39[] =
		"\x46\x61\x72\x20\x66\x61\x72\x20\x61\x77\x61\x79\x2c\x20\x62\x65"
		"\x68\x69\x6e\x64\x20\x74\x68\x65\x20\x77\x6f\x72\x64\x20\x6d\x6f"
		"\x75\x6e\x74\x61\x69\x6e\x73\x2c\x20\x66\x61\x72\x20\x66\x72\x6f"
		"\x6d\x20\x74\x68\x65\x20\x63\x6f\x75\x6e\x74\x72\x69\x65\x73\x20"
		"\x56\x6f\x6b\x61\x6c\x69\x61\x20\x61\x6e\x64\x20\x43\x6f\x6e\x73"
		"\x6f\x6e\x61\x6e\x74\x69\x61\x2c\x0d\x0a\x74\x68\x65\x72\x65\x20"
		"\x6c\x69\x76\x65\x20\x74\x68\x65\x20\x62\x6c\x69\x6e\x64\x20\x74"
		"\x65\x78\x74\x73\x2e\x20\x53\x65\x70\x61\x72\x61\x74\x65\x64\x20"
		"\x74\x68\x65\x79\x20\x6c\x69\x76\x65\x20\x69\x6e\x20\x42\x6f\x6f"
		"\x6b\x6d\x61\x72\x6b\x73\x67\x72\x6f\x76\x65\x20\x72\x69\x67\x68"
		"\x74\x20\x61\x74\x20\x74\x68\x65\x20\x63\x6f\x61\x73\x74\x20\x6f"
		"\x66\x0d\x0a\x74\x68\x65\x20\x53\x65\x6d\x61\x6e\x74\x69\x63\x73"
		"\x2c\x20\x61\x20\x6c\x61\x72\x67\x65\x20\x6c\x61\x6e\x67\x75\x61"
		"\x67\x65\x20\x6f\x63\x65\x61\x6e\x2e\x20\x41\x20\x73\x6d\x61\x6c"
		"\x6c\x20\x72\x69\x76\x65\x72\x20\x6e\x61\x6d\x65\x64\x20\x44\x75"
		"\x64\x65\x6e\x20\x66\x6c\x6f\x77\x73\x20\x62\x79\x20\x74\x68\x65"
		"\x69\x72\x20\x70\x6c\x61\x63\x65\x20\x61\x6e\x64\x0d\x0a\x73\x75"
		"\x70\x70\x6c\x69\x65\x73\x20\x69\x74\x20\x77\x69\x74\x68\x20\x74"
		"\x68\x65\x20\x6e\x65\x63\x65\x73\x73\x61\x72\x79\x20\x72\x65\x67"
		"\x65\x6c\x69\x61\x6c\x69\x61\x2e\x20\x49\x74\x20\x69\x73\x20\x61"
		"\x20\x70\x61\x72\x61\x64\x69\x73\x65\x6d\x61\x74\x69\x63\x20\x63"
		"\x6f\x75\x6e\x74\x72\x79\x2c\x20\x69\x6e\x20\x77\x68\x69\x63\x68"
		"\x20\x72\x6f\x61\x73\x74\x65\x64\x0d\x0a\x70\x61\x72\x74\x73\x20"
		"\x6f\x66\x20\x73\x65\x6e\x74\x65\x6e\x63\x65\x73\x20\x66\x6c\x79"
		"\x20\x69\x6e\x74\x6f\x20\x79\x6f\x75\x72\x20\x6d\x6f\x75\x74\x68"
		"\x2e\x0d\x0a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
		"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
	::memset(buff, 0x00, FAT::SectorSize * count);
	uint8_t* buffp = buff;
	for (int i = 0; i < count; i++, sector++, buffp += FAT::SectorSize) {
		switch (sector) {
		case 0: ::memcpy(buffp, sector0, sizeof(sector0)); break;
		case 1: ::memcpy(buffp, sector1, sizeof(sector1)); break;
		case 2: ::memcpy(buffp, sector2, sizeof(sector2)); break;
		case 3: ::memcpy(buffp, sector3, sizeof(sector3)); break;
		case 39: ::memcpy(buffp, sector39, sizeof(sector39)); break;
		default: break;
		}
	} 
	return RES_OK;	// RES_OK, RES_ERROR, RES_PARERR, RES_NOTRDY
}

DRESULT DummyDrive::write(const BYTE* buff, LBA_t sector, UINT count)
{
	::printf("write(sector=%d, count=%d)\n", sector, count);
	return RES_OK;	// RES_OK, RES_ERROR, RES_WRPRT, RES_PARERR, RES_NOTRDY
}

DRESULT DummyDrive::ioctl_CTRL_SYNC()
{
	::printf("ioctl(CTRL_SYNC)\n");
	return RES_OK;
}

DRESULT DummyDrive::ioctl_GET_SECTOR_COUNT(LBA_t* pSectorCount)
{
	::printf("ioctl(GET_SECTOR_COUNT)\n");
	*pSectorCount = 0;
	return RES_OK;
}

DRESULT DummyDrive::ioctl_GET_SECTOR_SIZE(WORD* pSectorSize)
{
	::printf("ioctl(GET_SECTOR_SIZE)\n");
	*pSectorSize = 512;
	return RES_OK;
}

DRESULT DummyDrive::ioctl_GET_BLOCK_SIZE(DWORD* pBlockSize)
{
	::printf("ioctl(GET_BLOCK_SIZE)\n");
	*pBlockSize = 1 << 0;
	return RES_OK;
}

DRESULT DummyDrive::ioctl_CTRL_TRIM(LBA_t startLBA, LBA_t endLBA)
{
	::printf("ioctl(CTRL_TRIM)\n");
	return RES_OK;
}

int main()
{
	::stdio_init_all();
#if 1
	FIL fil;
	char buff[80];
	DummyDrive driveDummy;
	driveDummy.Mount();
	FRESULT result = ::f_open(&fil, "/SAMPLE.TXT", FA_READ);
	if (result != FR_OK) {
		::printf("Error: %s\n", FAT::FRESULTToStr(result));
		return 1;
	}
	while (::f_gets(buff, sizeof(buff), &fil)) {
		::printf(buff);
	}
	::f_close(&fil);
#endif
}
