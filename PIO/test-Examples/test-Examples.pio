;------------------------------------------------------------------------------
.program spi_cpha0
.side_set 1
    out pins, 1 side 0 [1] ; Stall here on empty (sideset proceeds even if
    in pins, 1  side 1 [1] ; instruction stalls, so we stall with SCK low)

;------------------------------------------------------------------------------
.program spi_cpha1
.side_set 1
    out x, 1    side 0     ; Stall here on empty (keep SCK deasserted)
    mov pins, x side 1 [1] ; Output data, assert SCK (mov pins uses OUT mapping)
    in pins, 1  side 0     ; Input data, deassert SCK

;------------------------------------------------------------------------------
.program uart_rx
start:
    wait 0 pin 0        ; Stall until start bit is asserted
    set x, 7    [10]    ; Preload bit counter, then delay until halfway through
bitloop:                ; the first data bit (12 cycles incl wait, set).
    in pins, 1          ; Shift data bit into ISR
    jmp x-- bitloop [6] ; Loop 8 times, each loop iteration is 8 cycles
    jmp pin good_stop   ; Check stop bit (should be high)

    irq 4 rel           ; Either a framing error or a break. Set a sticky flag,
    wait 1 pin 0        ; and wait for line to return to idle state.
    jmp start           ; Don't push data if we didn't see good framing.

good_stop:              ; No delay before returning to start; a little slack is
    push                ; important in case the TX clock is slightly too fast.

;------------------------------------------------------------------------------
.program uart_tx
.side_set 1 opt
    pull       side 1 [7]  ; Assert stop bit, or stall with line in idle state
    set x, 7   side 0 [7]  ; Preload bit counter, assert start bit for 8 clocks
bitloop:                   ; This loop will run 8 times (8n1 UART)
    out pins, 1            ; Shift 1 bit from OSR to the first OUT pin
    jmp x-- bitloop   [6]  ; Each loop iteration is 8 cycles.

;------------------------------------------------------------------------------
.program ws2812
.side_set 1
.define public T1 3
.define public T2 3
.define public T3 4
.wrap_target
bitloop:
    out x, 1       side 0 [T3 - 1] ; Side-set still takes place when instruction stalls
    jmp !x do_zero side 1 [T1 - 1] ; Branch on the bit we shifted out. Positive pulse
do_one:
    jmp  bitloop   side 1 [T2 - 1] ; Continue driving high, for a long pulse
do_zero:
    nop            side 0 [T2 - 1] ; Or drive low, for a short pulse
.wrap

;------------------------------------------------------------------------------
.program manchester_tx
.side_set 1 opt
.wrap_target
do_1:
    nop         side 0 [5] ; Low for 6 cycles (5 delay, +1 for nop)
    jmp get_bit side 1 [3] ; High for 4 cycles. 'get_bit' takes another 2 cycles
do_0:
    nop         side 1 [5] ; Output high for 6 cycles
    nop         side 0 [3] ; Output low for 4 cycles
public start:
get_bit:
    out x, 1               ; Always shift out one bit from OSR to X, so we can
    jmp !x do_0            ; branch on it. Autopull refills the OSR when empty.
.wrap

;------------------------------------------------------------------------------
.program pwm
.side_set 1 opt
    pull noblock    side 0 ; Pull from FIFO to OSR if available, else copy X to OSR.
    mov x, osr             ; Copy most-recently-pulled value back to scratch X
    mov y, isr             ; ISR contains PWM period. Y used as counter.
countloop:
    jmp x!=y noset         ; Set pin high if X == Y, keep the two paths length matched
    jmp skip        side 1
noset:
    nop                    ; Single dummy cycle to keep the two paths the same length
skip:
    jmp y-- countloop      ; Loop until Y hits 0, then pull a fresh PWM value from FIFO

;------------------------------------------------------------------------------
.program quadrature_encoder
.origin 0
; 00 state
    JMP update    ; read 00
    JMP decrement ; read 01
    JMP increment ; read 10
    JMP update    ; read 11

; 01 state
    JMP increment ; read 00
    JMP update    ; read 01
    JMP update    ; read 10
    JMP decrement ; read 11

; 10 state
    JMP decrement ; read 00
    JMP update    ; read 01
    JMP update    ; read 10
    JMP increment ; read 11

; 11 state
    JMP update    ; read 00
    JMP increment ; read 01
decrement:
    JMP Y--, update ; read 10

.wrap_target
update:
    MOV ISR, Y      ; read 11
    PUSH noblock

sample_pins:
    OUT ISR, 2
    IN PINS, 2

    MOV OSR, ISR
    MOV PC, ISR

increment:
    MOV Y, ~Y
    JMP Y--, increment_cont
increment_cont:
    MOV Y, ~Y
.wrap    ; the .wrap here avoids one jump instruction and saves a cycle too

;------------------------------------------------------------------------------
.program quadrature_encoder_substep
.origin 0
	IN X, 32
	IN Y, 32

update_state:
	OUT ISR, 2
	IN PINS, 2
	MOV OSR, ~ISR
	MOV PC, OSR

decrement:
	JMP Y--, decrement_cont
decrement_cont:
	SET X, 1
	MOV X, ::X
check_fifo:
.wrap_target
	JMP X--, check_fifo_cont
check_fifo_cont:
	MOV PC, ~STATUS

increment:
	MOV Y, ~Y
	JMP Y--, increment_cont
increment_cont:
	MOV Y, ~Y
	SET X, 0
	.wrap

invalid:
	JMP update_state

	JMP invalid
	JMP increment		[0]
	JMP decrement		[1]
	JMP check_fifo		[4]

	JMP decrement		[1]
	JMP invalid
	JMP check_fifo		[4]
	JMP increment		[0]

	JMP increment		[0]
	JMP check_fifo		[4]
	JMP invalid
	JMP decrement		[1]

	JMP check_fifo		[4]
	JMP decrement		[1]
	JMP increment		[0]
	JMP update_state	[1]

;------------------------------------------------------------------------------
.program i2c
.side_set 1 opt pindirs
do_nack:
    jmp y-- entry_point        ; Continue if NAK was expected
    irq wait 0 rel             ; Otherwise stop, ask for help

do_byte:
    set x, 7                   ; Loop 8 times
bitloop:
    out pindirs, 1         [7] ; Serialise write data (all-ones if reading)
    nop             side 1 [2] ; SCL rising edge
    wait 1 pin, 1          [4] ; Allow clock to be stretched
    in pins, 1             [7] ; Sample read data in middle of SCL pulse
    jmp x-- bitloop side 0 [7] ; SCL falling edge

    ; Handle ACK pulse
    out pindirs, 1         [7] ; On reads, we provide the ACK.
    nop             side 1 [7] ; SCL rising edge
    wait 1 pin, 1          [7] ; Allow clock to be stretched
    jmp pin do_nack side 0 [2] ; Test SDA for ACK/NAK, fall through if ACK

public entry_point:
.wrap_target
    out x, 6                   ; Unpack Instr count
    out y, 1                   ; Unpack the NAK ignore bit
    jmp !x do_byte             ; Instr == 0, this is a data record.
    out null, 32               ; Instr > 0, remainder of this OSR is invalid
do_exec:
    out exec, 16               ; Execute one instruction per FIFO word
    jmp x-- do_exec            ; Repeat n + 1 times
.wrap
